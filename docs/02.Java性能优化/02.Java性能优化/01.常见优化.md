---
date: 2019-11-09 18:50:00
tags: 
  - Java
  - 性能优化
categories: Java性能优化
title: Java性能优化
permalink: /pages/203cfb/
---

# Java性能优化

## 尽量在合适的场合使用单例

使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：

::: tip
1. 控制资源的使用，通过线程同步来控制资源的并发访问；
2. 控制实例的产生，以达到节约资源的目的；
3. 控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信；
:::

## 尽量避免随意使用静态变量

当某个对象被定义为 static 变量所引用，那么`GC`通常是不会回收这个对象所占有的内存，如：

```java
public class A {
    private static B b = new B();
}
```

此时静态变量 b 的生命周期与 A 类同步，如果 A 类不会卸载，那么 b 对象会常驻内存，直到程序终止。

## 尽量避免过多过常地创建 Java 对象

尽量避免在经常调用的方法，循环中`new`对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度地重用对象，最好能用基本的数据类型或数组来替代对象。

## 尽量使用 final 修饰符

带有`final`修饰符的类是不可派生的。

在`Java`核心 API 中，有许多应用`final`的例子，例如 java.lang.String，为`String`类指定`final`防止了使用者覆盖 length()方法。

另外，如果一个类是`final`的，则该类所有方法都是`final`的。java 编译器会寻找机会内联（inline）所有的 final 方法（这和具体的编译器实现有关），此举能够使性能平均提高 50%。

## 尽量使用局部变量

调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快；

其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。

## 尽量处理好包装类型和基本类型两者的使用场所

虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。

::: tip
在集合类对象，有对象方面需要的处理使用包装类型，其他的处理提倡使用基本类型。
::: 

## 尽量减小 synchronize 的方法

都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。`synchronize`方法被调用时，直接会把当前对象锁了，在方法执行完之前其他线程无法调用当前对象的其他方法。

::: tip
所以，`synchronize`的方法尽量减小，并且应尽量使用方法同步代替代码块同步。
:::

## 尽量不要使用 finalize 方法

实际上，将资源清理放在`finalize`方法中完成是非常不好的选择，由于`GC`的工作量很大，尤其是回收`Young`代内存时，大都会引起应用程序暂停，所以再选择使用`finalize`方法进行资源清理，会导致`GC`负担更大，程序运行效率更差。

## 尽量使用基本数据类型代替对象

```java
String str = "hello";
```

上面这种方式会创建一个“hello”字符串，而且`JVM`的字符缓存池还会缓存这个字符串；

```java
String str = new String("hello");
```


此时程序除创建字符串外，`str`所引用的`String`对象底层还包含一个`char[]`数组，这个`char[]`数组依次存放了 h,e,l,l,o 。

## 多线程在未发生线程安全前提下应尽量使用 HashMap、ArrayList

HashTable、Vector 等使用了同步机制，降低了性能。

## 尽量合理的创建 HashMap

当你要创建一个比较大的`hashMap`时，充分利用这个构造函数

```java
public HashMap(int initialCapacity, float loadFactor);
```


避免 HashMap 多次进行了`hash`重构,扩容是一件很耗费性能的事，在默认中`initialCapacity`只有16，而`loadFactor`是0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的 Hashtable，Vectors 也是一样的道理。

## 尽量减少对变量的重复计算

```java
//减少对 list.size() 的重复计算
for (int i = 0, length = list.size(); i < length; i++) {
	System.out.println(list.get(i));
}
```

## 尽量避免不必要的创建

```java
A a = new A();
if(i == 1){
    list.add(a);
}
应该改为
if(i == 1){
    A a = new A();
    list.add(a);
}  

```

## 尽量在 finally 块中释放资源

程序中使用到的资源应当被释放，以避免资源泄漏，这最好在 finally 块中去做。
::: tip
不管程序执行的结果如何，`finally`块基本总是会执行的，以确保资源的正确关闭。
:::

## 尽量使用移位来代替'a/b'的操作

```java
// "/"是一个代价很高的操作，使用移位的操作将会更快和更有效
int num = a / 4;
应该改为
int num = a >> 2;
//但是注意的是，使用移位应添加注释，因为移位操作不直观，比较难理解
```

## 尽量使用移位来代替'a*b'的操作

```java
int num = a * 4;
应该改为
int num = a << 2;
```

## 尽量确定 StringBuffer 的容量

`StringBuffer`的构造器会创建一个默认大小（通常是 16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。

::: tip
在大多数情况下，你可以在创建`StringBuffer`的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。
:::

## 尽量早释放无用对象的引用

大部分时，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为`null`。

例如：

```java
public void test(){
    Object obj = new Object();
    ......
    obj = null;
}
```

上面这个就没必要了，随着方法 test()的执行完成，程序中 obj 引用变量的作用域就结束了。但是如果是改成下面：

```java
public void test(){
    Object obj = new Object();
    ......
    obj = null;
    ......
}
```

这时候就有必要将 obj 赋值为`null`，可以尽早的释放对 Object 对象的引用。

## 尽量避免使用二维数组

二维数据占用的内存空间比一维数组多得多，大概 10 倍以上。

## 尽量避免使用 split

除非是必须的，否则应该避免使用`split`，`split`由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用`split`， 可以考虑使用`apache`的 StringUtils.split(string,char)，频繁`split`可以缓存结果。

## ArrayList & LinkedList

一个是线性表，一个是链表，一句话，随机查询尽量使用`ArrayList`，`LinkedList`还要移动指针，添加删除的操作`LinkedList`优于`ArrayList`，`ArrayList`还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好两者的数据结构，对症下药。

## 尽量使用System.arraycopy ()代替通过来循环复制数组

`System.arraycopy()`要比通过循环来复制数组快的多。

## 尽量缓存经常使用的对象

尽可能将经常使用的对象进行缓存，可以使用数组，或`HashMap`的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如`EhCache`，`Oscache`进行缓存，他们基本都实现了`FIFO/FLU`等缓存算法。

## 尽量避免非常大的内存分配

有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。

## 慎用异常

当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个`Exception`时，`JVM`不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。

如果您创建一个`Exception` ，就得付出代价，好在捕获异常开销不大，因此可以使用`try-catch`将核心内容包起来。从技术上讲，你甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是`throw`操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。

真正要花代价的是创建异常，幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。

## 尽量重用对象

特别是 String 对象的使用中，出现字符串连接情况时应使用`StringBuilder`或者 `StringBuffer`代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。

因此生成过多的对象将会给程序的性能带来很大的影响。

## 不要重复初始化变量

默认情况下，调用类的构造函数时，`Java`会把变量初始化成确定的值，所有的对象被设置成`null`，整数变量设置成 0，`float`和`double`变量设置成 0.0，逻辑值设置成`false`。当一个类从另一个类派生时，这一点尤其应该注意，因为用`new`关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。

这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法。比如 initXXX()中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：public int state = this.getState()。

## 用构造函数来初始化 StringBuffer 容量

`StringBuffer`的默认容量为 16，当`StringBuffer`的容量达到最大容量时，它会将自身容量增加到当前的 2 倍+2，也就是 2*n+2。无论何时，只要`StringBuffer`到达它的最大容量，它就不得不创建一个新的对象数组，然后复制旧的对象数组，这会浪费很多时间。

::: tip
所以给`StringBuffer`设置一个合理的初始化容量值，是很有必要的。
:::

## 不用 new 关键字创建对象的实例

用`new`关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。

但如果一个对象实现了`Cloneable`接口，我们可以调用它的`clone()`方法。`clone()`方法不会调用任何类构造函数。

## 对 于 常 量 字 符 串 ， 用 'String' 代 替 'StringBuffer'

常量字符串并不需要动态改变长度。

```java
public class USC {
	String method(){
        StringBuffer s = new StringBuffer("Hello");
        String str = s + " World!";
        return t;
    }
}
```

::: tip
更正：把`StringBuffer`换成`String`，如果确定这个`String`不会再变的话，这将会减少运行开销提高性能。
:::

## 在 finally 块中关闭 Stream

程序中使用到的资源应当被释放，以避免资源泄漏。这最好在`finally`块中去做。不管程序执行的结果如何，`finally`块总是会执行的，以确保资源的正确关闭。

## 在字符串相加的时候，使用 ' ' 代替 " "，如果该字符串只有一个字符的话

```java
public class STR {
    public void method(String s) {
        String str = s + 'd';//String str = s + "d"
    }
}
```

## 为 Vectors  和 Hashtables 定义初始大小 

`JVM`为`Vector`扩充大小的时候需要重新创建一个更大的数组，将原来数组中的内容复制过来，最后，原来的数组会被回收。可见`Vector`容量的扩大是一个颇费时间的事。

::: tip
通常，默认的10个元素大小是不够的。最好能准确得估计所需要的最佳大小。
:::

## HaspMap 的遍历

```java
Map<String, String[]> map = new HashMap<>();
for (Map.Entry<String, String[]> entry : map.entrySet()) {
    String key = entry.getKey();
    String[] value = entry.getValue();
}
```

## 尽量避免 BigInteger  &  BigDecimal

我们来看下`BigInteger`和`BigDecimal`。尤其是后者，由于其精度高而受欢迎。但这是有代价的。

`BigInteger`和`BigDecimal`比简单的`long`或`double`需要更多的内存，并且大大降低所有的计算速度。因此，如果你需要额外的精度，或者你的数字超过了一个`long`范围，最好三思而后行。这可能是你在提升性能问题中唯一需要更改的地方，特别是当你正在实现一个数学算法。

## array(数组)和 ArrayList 的使用

`array`数组效率最高，但容量固定，无法动态改变，`ArrayList`容量可以动态增长，但牺牲了效率。

## 单线程应尽量使用 HashMap | ArrayList
HashTable、Vector，它们使用了同步机制，而降低了性能，除非必要，否则不推荐使用。

## 考虑使用静态方法

如果你没有必要去访问对象的外部，那么就让方法成为静态方法。这样它会被更快地调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。




